// -*- mode: java -*-

#ifdef JAVA
import java.awt.Event;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Image;
import java.util.Random;

#ifdef DEBUG
import java.awt.Frame;
#endif

// #define EXTRA_DEBUG
// #define DEBUG_ZOC
// #define DEBUG_AI

#ifdef PRINTABLE
import java.awt.image.BufferedImage;
import java.io.File;
import javax.imageio.ImageIO;
#endif

#endif

/*
 4k General

 https://github.com/lifelike/4kgeneral
 http://java4k.com/index.php?action=games&method=view&gid=400

 Based on a template by appel, edited by bysse (and possible others)
 http://www.javagaming.org/index.php/topic,21626.msg181270.html#msg181270

(C) Copyright 2012, 2013, 2014 Pelle Nilsson

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met: 

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer. 
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution. 

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

#define WHITE 0xffffff
#define BLACK 0
#define RED 0xff0000

#ifdef JAVA
public class G
#if defined(APPLET)
    extends java.applet.Applet
#elif defined(DEBUG) || defined(PRINTABLE)
    extends java.awt.Canvas
#endif
{
#ifdef PRINTABLE
    #define ZOOM 5
#else
    #define ZOOM 1
#endif

#define str_concat +

#define const_string(name) private final static String name
#define const_byte_array(name) private final static byte[] name
#define new_byte_array new byte[]
#define sized_byte_array(name, size) private final static byte[] name = new byte[size]
#define const_int_array(name) private final static int[] name
#define int_array(name) int[] name
#define new_int_array new int[]
#define char_at(a, i) a.charAt(i)

#define declare_random(name) Random name
#define init_random(name, seed) name = new Random(seed)
#define random_int(name, limit) name .nextInt(limit)

#define set_color(c) g.setColor(new Color(c))
#define fill_rect(x, y, w, h) g.fillRect(x, y, w, h)
#define blit_buffer() pg.drawImage(bufferImage, 0, 0, this)
#define draw_string(s, x, y) g.drawString(s, x, y)

#endif

#ifdef C

#include <assert.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define str_concat

#define ZOOM 1

#define private
#define boolean bool
#define const_byte_array(name) int8_t name[]
#define new_byte_array
#define sized_byte_array(name, size) int8_t name[size]
#define const_int_array(name) int32_t name[]
#define int_array(name) int32_t name[]
#define new_int_array
#define const_string(name) char name[]
#define byte int8_t
#define char_at(a, i) a[i]

#define RANDOM_STATE_SIZE 64

#define declare_random(name) char name[RANDOM_STATE_SIZE]
#define init_random(name, seed) initstate(seed, name, RANDOM_STATE_SIZE)
#define random_int(name, limit) (setstate(name), random() % limit)

void paint();

void repaint() {
    paint();
}

#ifdef SDL
    #include <SDL.h>

    SDL_Window *window = NULL;
    SDL_Surface *screen = NULL;
    SDL_Surface *font = NULL;
    Uint32 global_color = 0;

#define fill_rect(x, y, w, h) fill_sdl_rect(x, y, w, h)
#define blit_buffer() SDL_UpdateWindowSurface(window)
#define draw_string(s, x, y) draw_sdl_string(s, x, y)

#define set_color(c) global_color = make_color(c)

// convert from 0x00rrggbb to SDL screen pixel format
// FIXME currently assuming screen already has input format
Uint32 make_color(Uint32 c) {
    return c;
}

void fill_sdl_rect(int x, int y, int w, int h) {
    SDL_Rect rect;
    rect.x = x;
    rect.y = y;
    rect.w = w;
    rect.h = h;
    SDL_FillRect(screen, &rect, global_color);
}

#define SDL_FONT_CHAR_WIDTH 10
#define SDL_FONT_CHAR_HEIGHT 24
#define SDL_FONT_CHAR_BASELINE 18
#define SDL_FONT_CHARS_PER_ROW 20
#define SDL_FONT_START_CHAR 32

void draw_sdl_string(char *s, int x, int y) {
    SDL_Rect src;
    SDL_Rect dst;
    src.w = SDL_FONT_CHAR_WIDTH;
    src.h = SDL_FONT_CHAR_HEIGHT;
    for (int i = 0; i < strlen(s); i++) {
        int c = s[i] - SDL_FONT_START_CHAR;
        src.x = (c % SDL_FONT_CHARS_PER_ROW) * SDL_FONT_CHAR_WIDTH;
        src.y = (c / SDL_FONT_CHARS_PER_ROW) * SDL_FONT_CHAR_HEIGHT;
        src.w = SDL_FONT_CHAR_WIDTH;
        src.h = SDL_FONT_CHAR_HEIGHT;
        dst.x = x + i * SDL_FONT_CHAR_WIDTH;
        dst.y = y - SDL_FONT_CHAR_BASELINE;
        SDL_BlitSurface(font, &src, screen, &dst);
    }
}

#else

#define set_color(c)
#define fill_rect(x, y, w, h)
#define blit_buffer()
#define draw_string(s, x, y)

#endif



#endif

    #define HEX_HEIGHT (46 * ZOOM)
     // HEX_WIDTH ~= HEX_HEIGHT * 1.155;
    #define HEX_WIDTH (60 * ZOOM)
    #define MAP_COLUMNS (17)
    #define MAP_ROWS (10)
    #define MAP_WIDTH ((1 + MAP_COLUMNS) * 3 / 4 * HEX_WIDTH)
    #define MAP_HEIGHT (MAP_ROWS * HEX_HEIGHT + HEX_HEIGHT)
    #define MAP_FIRST_COLUMN_CENTER_X (HEX_WIDTH / 2)
    #define MAP_COLUMN_DISTANCE (HEX_WIDTH * 3 / 4)
    #define MAP_EVEN_ROW_LAYER (HEX_HEIGHT / 2)
    #define MAP_HEXES (MAP_COLUMNS * MAP_ROWS)

    #define NO_UNIT (0)
    #define INFANTRY (1)
    #define TANK (2)
    #define ARTILLERY (3)
    #define ENGINEER (4)

    #define NR_UNIT_TYPES (ENGINEER)

    #define BITMAP_DATA_WIDTH (8)
    #define BITMAP_DATA_HEIGHT (8)
    #define BITMAP_DATA_SIZE (BITMAP_DATA_WIDTH * BITMAP_DATA_HEIGHT)
    #define BITMAP_SCALE (3 * ZOOM)
    #define BITMAP_WIDTH (BITMAP_DATA_WIDTH * BITMAP_SCALE)
    #define BITMAP_HEIGHT (BITMAP_DATA_HEIGHT * BITMAP_SCALE)
    #define BITMAP_SELECTED (0)
    #define BITMAP_LAST_UNIT (NR_UNIT_TYPES)
    #define BITMAP_MOVE_TARGET (BITMAP_LAST_UNIT + 1)
    #define BITMAP_ATTACK_TARGET (BITMAP_LAST_UNIT + 2)
    #define BITMAP_FUTURE_TURN (BITMAP_LAST_UNIT + 3)
    #define BITMAP_TURN (BITMAP_LAST_UNIT + 4)
    #define NR_BITMAPS (BITMAP_TURN + 1)

    const_string(BITMAP_DATA) =
#include "G.images.h"
        ;


    private byte turn;
    private byte state;

    /**
     * Campaigns are stored in an array of bytes, three per scenario,
     * The first one being used as random seed for the map, the other
     * for the units (friendly, enemy). The order of scenarios can
     * also be important. For instance new unit types are introduced
     * based on what level has been reached, ignoring the campaign
     * data.
     */

    /**
     * Base percentage of hex containing woods.
     */
    #define WOODS_BASE (10)

    /**
     * Increased percentage of hex containing woods
     * for each of hex above and to the left that contains woods.
     */
        #define WOODS_SPREAD (30)

        #define MAX_NR_RIVERS (3)

        #define FIRST_POSSIBLE_RIVER_COLUMN (3)

    /**
     * Percentage of hexes behind rivers that have no other unit
     * that will receive an infantry unit.
     */
        #define RIVER_LINE_GARRISON (50)

        #define BRIDGE_PERCENT (5)

        #define CAMPAIGN_FRIENDLY_COLUMNS (FIRST_POSSIBLE_RIVER_COLUMN)
    /**
     * Minimum size of no man's land.
     */
        #define CAMPAIGN_MIN_NML (3)

    // following are culmulative percentages
        #define CAMPAIGN_FRIENDLY_INFANTRY (17)
        #define CAMPAIGN_FRIENDLY_TANK (24)
        #define CAMPAIGN_FRIENDLY_ARTILLERY (30)
        #define CAMPAIGN_FRIENDLY_ENGINEER (35)

    // for the enemy we use random number 0-999 instead
    // because of the much larger area covered
        #define CAMPAIGN_ENEMY_INFANTRY (35)
        #define CAMPAIGN_ENEMY_TANK (45)
        #define CAMPAIGN_ENEMY_ARTILLERY (50)

    const_byte_array(campaign) = new_byte_array {
        0x29, 0x33, 0x39,
        0x30, 0x1f, 0x22,
        0x2b, 0x22, 0x22,
        0x34, 0x7a, 0x74,
        0x35, 0x42, 0x71,
        0x45, 0x52, 0x01,
        0x55, 0x62, 0x11,
        0x65, -112, 0x32,
        0x0a, 0x15, 0x31,
        0x19, 0x74, 0x4a,
        0x53, 0x54, -97,
        0x55, 0x57, -92,
    };

    #define LAST_CAMPAIGN_SCENARIO (11)

        #define COLOR_FRIENDLY_BACKGROUND (0x386bb9)
        #define COLOR_FRIENDLY_BORDER (0x0d38b9)
        #define COLOR_ENEMY_BACKGROUND (0xe5a047)
        #define COLOR_ENEMY_BORDER (0xb93838)
        #define COLOR_MOVED_BORDER (0x878787)
        #define COLOR_OPEN (0xffffed)
        #define COLOR_WOODS_1 (0x3a691d)
        #define COLOR_WOODS_2 (0x62875b)
        #define COLOR_WATER_1 (0x62a7a7)
        #define COLOR_WATER_2 (0x404aa7)
        #define COLOR_CITY_1 (0x624848)
        #define COLOR_CITY_2 (0xa78787)
        #define COLOR_RED_1 (0xff0037)
        #define COLOR_RED_2 (0xff4037)
        #define COLOR_GREEN_1 (0x62ff00)
        #define COLOR_GREEN_2 (0x3aa700)

    // defining how to draw map "hexes" (more like circles)
    // for each terrain type the listed values are:
        #define TERRAIN_DRAW_COLOR_1 (0)
        #define TERRAIN_DRAW_COLOR_2 (1)
        #define TERRAIN_DRAW_X_SPREAD_OFFSET (2)
        #define TERRAIN_DRAW_WIDTH_OFFSET (3)
        #define TERRAIN_DRAW_HEIGHT_OFFSET (4)
        #define TERRAIN_DRAW_AMOUNT_OFFSET (5)
        #define TERRAIN_DEFENSE_OFFSET (6)
        #define TERRAIN_MOVE_COST_OFFSET (7)
        #define TERRAIN_DATA_SIZE (TERRAIN_MOVE_COST_OFFSET + 1)

    // terrain defense is chance of eliminating a unit in that terrain
    // (multiply by 5 to get chance in %)

    int_array(terrainData) = new_int_array {
        0, 0, 0, 0, 0, 0, 9, 1,
        COLOR_WOODS_1, COLOR_WOODS_2, HEX_WIDTH * 7 / 10, 4, 4, 0x87, 6, 2,
        COLOR_CITY_1, COLOR_CITY_2, HEX_WIDTH * 4 / 5, 7, 7, 45, 5, 1,
        COLOR_WATER_1, COLOR_WATER_2, HEX_WIDTH / 4, 3, HEX_HEIGHT / 3, 30, 9,
        13
    };

    #define SCREEN_MAP_Y (BITMAP_HEIGHT)
    #define SCREEN_WIDTH (MAP_WIDTH)
    #define SCREEN_HEIGHT (MAP_HEIGHT + SCREEN_MAP_Y + 2)
        #define SCREEN_STATUS_BAR_TEXT_Y (BITMAP_HEIGHT - 3)
        #define SCREEN_TURN_LABEL_X (10)
        #define SCREEN_TURN_NR_X (50)
        #define SCREEN_TURN_SLASH_X (65)
        #define SCREEN_TURN_TOTAL_X (70)
        #define SCREEN_LEVEL_LABEL_X (140)
        #define SCREEN_LEVEL_NR_X (180)
        #define SCREEN_BUTTON_X (SCREEN_WIDTH - 100)
        #define SCREEN_BUTTON_TEXT_X (SCREEN_WIDTH - 80)
        #define SCREEN_BUTTON_HEIGHT (BITMAP_HEIGHT)
        #define SCREEN_MESSAGE_X (300)

        #define UNIT_BORDER_WIDTH (2)

        #define CLEAR (0)
        #define WOODS (1)
        #define CITY (2)
        #define WATER (3)
        #define NR_TERRAIN_TYPES (4)

        #define CITY_RARITY (40)

        #define NR_TURNS (15)

        #define SEARCH_STATE_BIT (64)

        #define NEW_LEVEL (1)
        #define NEW_TURN (2 | SEARCH_STATE_BIT)
        #define SELECT_UNIT_TO_MOVE (3)
        #define MARK_UNIT_TO_MOVE (4)
        #define FIND_MOVE_TARGETS (5 | SEARCH_STATE_BIT)
        #define FIND_ATTACK_TARGETS (6 | SEARCH_STATE_BIT)
        #define SHOW_TARGETS (7)
        #define FIND_ENEMY_MOVE_TARGETS (8 | SEARCH_STATE_BIT)
        #define FIND_ENEMY_ZOC (9 | SEARCH_STATE_BIT)
        #define FIND_FRIENDLY_ZOC (10 | SEARCH_STATE_BIT)
        #define WON_CAMPAIGN (11)
        #define WON_LEVEL (12)
        #define FAIL_LEVEL (13)
        #define FIND_FRIENDLY_FOV (14 | SEARCH_STATE_BIT)
        #define SELECT_ENEMY_UNIT_TO_MOVE (15 | SEARCH_STATE_BIT)
        #define FIND_ENEMY_ATTACK_TARGETS (16 | SEARCH_STATE_BIT)
        #define FIND_FRIENDLY_THREAT (17 | SEARCH_STATE_BIT)
        #define FIND_ENEMY_THREAT (18 | SEARCH_STATE_BIT)
        #define FIND_ENEMY_VALUE (19| SEARCH_STATE_BIT)

#ifdef DEBUG
    byte debugPlace = NO_UNIT;

#define NONE_SEARCH_STATE_MASK (63)
    private final static String[] stateNames
    = new String[] {"0",
                    "NEW_LEVEL",
                    "NEW_TURN",
                    "SELECT_UNIT_TO_MOVE",
                    "MARK_UNIT_TO_MOVE",
                    "FIND_MOVE_TARGETS",
                    "FIND_ATTACK_TARGETS",
                    "SHOW_TARGETS",
                    "FIND_ENEMY_MOVE_TARGETS",
                    "FIND_ENEMY_ZOC",
                    "FIND_FRIENDLY_ZOC",
                    "WON_CAMPAIGN",
                    "WON_LEVEL",
                    "FAIL_LEVEL",
                    "FIND_FRIENDLY_FOV",
                    "SELECT_ENEMY_UNIT_TO_MOVE",
                    "FIND_ENEMY_ATTACK_TARGETS",
                    "FIND_FRIENDLY_THREAT",
                    "FIND_ENEMY_THREAT",
                    "FIND_ENEMY_VALUE",
                   };
#endif

    #define MARK_NONE (-1)
    #define MARK_SELECTED (BITMAP_SELECTED)
    #define MARK_MOVE_TARGET (BITMAP_MOVE_TARGET)
    #define MARK_ATTACK_TARGET (BITMAP_ATTACK_TARGET)

    private int level = 0;

#define MAP_TERRAIN_LAYER (0)
    #define MAP_FRIENDLY_UNIT_LAYER (1)
    #define MAP_MARK_LAYER (2)
    #define MAP_FRIENDLY_MOVED_LAYER (3)
    #define MAP_FRIENDLY_FOV_LAYER (4)
    #define MAP_ENEMY_UNIT_LAYER (5)
    #define MAP_ZOC_LAYER (6)
    #define MAP_MOVE_COST_LAYER (7)
    #define MAP_RANGE_LAYER (8)
    #define MAP_TMP_LAYER (9)
    #define MAP_FRIENDLY_THREAT_LAYER (10)
    #define MAP_ENEMY_THREAT_LAYER (11)
    #define MAP_ENEMY_VALUE_LAYER (12)
    #define MAP_ENEMY_MOVED_LAYER (13)
    #define MAP_ATTACKED_LAYER (14)

    #define MAP_DATA_SIZE (15)
    #define MAP_DATA_TOTAL_SIZE (MAP_COLUMNS * MAP_ROWS * MAP_DATA_SIZE)
    sized_byte_array(map, MAP_DATA_TOTAL_SIZE);

#ifdef DEBUG
#define FOV_RANGE 20
#else
#define FOV_RANGE 6
#endif

    #define DEFENDER_FIRE_BACK (6)

    // ****** AI TWEAKS BEGIN

    #define DEFAULT_ZOC_VALUE (10)
    #define VALUE_SEARCH_ITERATIONS (10)
    #define THREAT_SEARCH_ITERATIONS (10)
    #define CITY_VALUE (30)
    #define ARTILLERY_DEFEND_VALUE (5)

    // ****** AI TWEAKS END


    /*
     * For each unit type in unitData:
     * range (eg for artillery)
     * movement allowance
     *
     * Note that movement rates and ranges are 1 more than what you
     * actually see in the game, because the search is decreasing, and
     * upon reaching 1 a unit can not go further. This saves us from
     * adding code to +1 later.
     *
     * All units have a movement allowance of 12, but different costs
     * for different terrain types.
     */
    #define UNIT_THREAT (5)

    #define UNIT_RANGE_OFFSET (0)
    #define UNIT_MOVE_OFFSET (1)
    #define UNIT_SIZE (UNIT_MOVE_OFFSET + 1)
    const_byte_array(unitData) = new_byte_array {
            //INFANTRY
            2, 5,
            //TANK
            2, 7,
            //ARTILLERY
            4, 3,
            //ENGINEER
            2, 5
        };

declare_random(rnd);

#ifdef JAVA
    public void start() {
#else
    void start() {
#endif
        declare_random(mapRnd);
        declare_random(funitsRnd);
        declare_random(eunitsRnd);
        state = NEW_LEVEL;
        turn = 1;

        init_random(rnd, 0);
        init_random(mapRnd, campaign[level * 3]);
        init_random(funitsRnd, campaign[level * 3 + 1]);
        init_random(eunitsRnd, campaign[level * 3 + 2]);

#ifdef DEBUG
        System.out.println("start level " + level
                           + " (scenario: 0x"
                           + Integer.toHexString(campaign[level * 3])
                           + " 0x"
                           + Integer.toHexString(campaign[level * 3 + 1])
                           + " 0x"
                           + Integer.toHexString(campaign[level * 3 + 2])
                           + ")");
#endif

        for (int i = 0; i < MAP_DATA_TOTAL_SIZE; i += MAP_DATA_SIZE) {
            byte initTerrain = CLEAR;
            if (random_int(mapRnd, CITY_RARITY) == 0) {
                initTerrain = CITY;
            }
            map[i + MAP_TERRAIN_LAYER] = initTerrain;
            map[i + MAP_FRIENDLY_UNIT_LAYER] = NO_UNIT;
            map[i + MAP_ENEMY_UNIT_LAYER] = NO_UNIT;
            map[i + MAP_MARK_LAYER] = MARK_NONE;
        }

        int i = 0;
        // add 0-2 rivers down hex columns (including render to bitmap)
        int nrRivers = random_int(mapRnd, MAX_NR_RIVERS);
        for (int n = 0; n < nrRivers; n++) {
           int c = FIRST_POSSIBLE_RIVER_COLUMN
               + random_int(mapRnd, MAP_COLUMNS - FIRST_POSSIBLE_RIVER_COLUMN);
           for (int r = 0; r < MAP_ROWS; r++) {
               map[(c * MAP_ROWS + r) * MAP_DATA_SIZE + MAP_TERRAIN_LAYER]
                   = WATER;
           }
        }

        int firstEnemyColumn = CAMPAIGN_FRIENDLY_COLUMNS
            + CAMPAIGN_MIN_NML
            + random_int(funitsRnd, MAP_COLUMNS / 4);
        i = 0;
        for (int c = 0; c < MAP_COLUMNS - 1; c++) {
            for (int r = 0; r < MAP_ROWS; r++) {
                byte terrain = map[i + MAP_TERRAIN_LAYER];
                if (terrain != WATER
                    && r > 0
                    && c > 0) {
                    int woods_percentage = WOODS_BASE;
                    if (map[i - MAP_DATA_SIZE * MAP_ROWS + MAP_TERRAIN_LAYER]
                        == WOODS) {
                        woods_percentage += WOODS_SPREAD;
                    }
                    if (map[i - MAP_DATA_SIZE + MAP_TERRAIN_LAYER] == WOODS) {
                        woods_percentage += WOODS_SPREAD;
                    }
                    if (random_int(mapRnd, 100) < woods_percentage) {
                        terrain = WOODS;
                    }
                }
                map[i + MAP_TERRAIN_LAYER] = terrain;
                byte unit = NO_UNIT;

                if ((c < CAMPAIGN_FRIENDLY_COLUMNS
                     || (level == 3 && c > (MAP_COLUMNS
                                            - CAMPAIGN_FRIENDLY_COLUMNS)))
                     && r > 0) {
                    int u = random_int(funitsRnd, 100);
                    if (u < CAMPAIGN_FRIENDLY_ENGINEER) {
                        unit = ENGINEER;
                    }
                    if (u < CAMPAIGN_FRIENDLY_ARTILLERY) {
                        unit = ARTILLERY;
                    }
                    if (u < CAMPAIGN_FRIENDLY_TANK) {
                        unit = TANK;
                    }
                    if (terrain == CITY || u < CAMPAIGN_FRIENDLY_INFANTRY) {
                        unit = INFANTRY;
                    }

                    if (terrain != WATER) {
                        map[i + MAP_FRIENDLY_UNIT_LAYER] = unit;
                        map[i + MAP_FRIENDLY_FOV_LAYER] = 1;
                    }
                } else if (c >= firstEnemyColumn) { // enemy territory
                    int u = random_int(eunitsRnd, 1000);
                    if (terrain == CITY || u < CAMPAIGN_ENEMY_INFANTRY) {
                        if (map[i + MAP_ROWS * MAP_DATA_SIZE
                                + MAP_TERRAIN_LAYER] != WATER) {
                            // add some artillery behind city
                            if (random_int(eunitsRnd, 2) == 0
                                && terrain == CITY) {
                                map[i + MAP_ROWS * MAP_DATA_SIZE
                                    + MAP_ENEMY_UNIT_LAYER] = ARTILLERY;
                            }
                        }
                        unit = INFANTRY;
                    } else if (u < CAMPAIGN_ENEMY_TANK) {
                        unit = TANK;
                    } else if (u < CAMPAIGN_ENEMY_ARTILLERY) {
                        unit = ARTILLERY;
                        if (map[i - MAP_ROWS * MAP_DATA_SIZE
                                + MAP_TERRAIN_LAYER] != WATER) {
                            // add some support in front of artillery
                            map[i - MAP_ROWS * MAP_DATA_SIZE
                                + MAP_ENEMY_UNIT_LAYER] = INFANTRY;
                        }
                    }
                    if (terrain == WATER) {
                        if (map[i + MAP_ROWS * MAP_DATA_SIZE
                                + MAP_TERRAIN_LAYER] != WATER) {
                            if (random_int(eunitsRnd, 100) < RIVER_LINE_GARRISON) {
                                unit = INFANTRY;
                            }
                            map[i + MAP_ROWS * MAP_DATA_SIZE
                                + MAP_ENEMY_UNIT_LAYER] = unit;
                        }
                    } else if (unit != NO_UNIT && terrain != WATER) {
                        map[i + MAP_ENEMY_UNIT_LAYER] = unit;
                    }
                }
                i += MAP_DATA_SIZE;
            }
        }
        repaint();
    }

#ifdef JAVA
    public void update(Graphics g) {
        paint(g);
    }
#endif

#ifdef JAVA
    public void paint(Graphics pg) {
#else
    void paint() {
#endif
        declare_random(drawRnd);
        /*
         * paint map terrain
         * paint units
         * paint marks
         */

#ifdef JAVA
#ifdef PRINTABLE
        Graphics g = pg;
#else
        Image bufferImage = createImage(SCREEN_WIDTH, SCREEN_HEIGHT);
        Graphics g = bufferImage.getGraphics();
#endif
#endif

       init_random(drawRnd, 0);

#ifdef PRINTABLE
        set_color(WHITE);
#else
	set_color(BLACK);
#endif
        fill_rect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

#if !defined(PRINTABLE)

        // draw the "status bar" and "end turn button"
        set_color(0xffffff);

#if defined(JAVA)
        // adding strings is expensive they say
        draw_string("TURN      / 15",
                     SCREEN_TURN_LABEL_X, SCREEN_STATUS_BAR_TEXT_Y);
        draw_string(Integer.toString(turn),
                     SCREEN_TURN_NR_X, SCREEN_STATUS_BAR_TEXT_Y);
        draw_string("MAP", SCREEN_LEVEL_LABEL_X, SCREEN_STATUS_BAR_TEXT_Y);
        draw_string(Integer.toString(level + 1),
                     SCREEN_LEVEL_NR_X, SCREEN_STATUS_BAR_TEXT_Y);
#elif defined(C)
        char *turn_string = malloc(100);
        snprintf(turn_string, 100, "TURN %d/15", turn);
        draw_string(turn_string, SCREEN_TURN_LABEL_X, SCREEN_STATUS_BAR_TEXT_Y);
        free(turn_string);
#endif

        if (state == FAIL_LEVEL) {
            draw_string("FAIL", SCREEN_MESSAGE_X, SCREEN_STATUS_BAR_TEXT_Y);
        }
        if (state == WON_LEVEL) {
            draw_string("WON", SCREEN_MESSAGE_X, SCREEN_STATUS_BAR_TEXT_Y);
        }
        if (state == WON_CAMPAIGN) {
            draw_string("WON ALL",
                         SCREEN_MESSAGE_X, SCREEN_STATUS_BAR_TEXT_Y);
        }

        set_color(COLOR_FRIENDLY_BORDER);
        fill_rect(SCREEN_BUTTON_X, 0, SCREEN_WIDTH, SCREEN_BUTTON_HEIGHT);
        set_color(COLOR_FRIENDLY_BACKGROUND);
        fill_rect(SCREEN_BUTTON_X + 2, 2,
                   SCREEN_WIDTH - 4, SCREEN_BUTTON_HEIGHT - 4);
        set_color(0xffffff);
        draw_string(">>", SCREEN_BUTTON_TEXT_X,
                     SCREEN_STATUS_BAR_TEXT_Y - 2);
#endif
        int i = 0;
        int x = MAP_FIRST_COLUMN_CENTER_X;
        for (int c = 0; c < MAP_COLUMNS; c++) {
            int y = ((c % 2 == 0) ? MAP_EVEN_ROW_LAYER : 0) + SCREEN_MAP_Y
                + HEX_HEIGHT / 2;

            for (int r = 0; r < MAP_ROWS; r++) {

                // **** draw hexagon begin ****
#ifdef PRINTABLE
                set_color(BLACK);
                fill_rect(x - HEX_WIDTH / 4, y - HEX_HEIGHT / 2 - ZOOM,
                           HEX_WIDTH / 2 + 1, HEX_HEIGHT + ZOOM * 2);
#endif

                set_color(COLOR_OPEN);

                for (int hx = 0; hx <= HEX_WIDTH / 4; hx++) {
                    int hy = hx * 155 / 100; // hex slope 60 degrees
#ifdef PRINTABLE
                    set_color(BLACK);
                    fill_rect(x - HEX_WIDTH / 2 + hx - ZOOM,
                              y - hy + 2,
                              (HEX_WIDTH / 2 - hx) * 2 + 2 * ZOOM,
                              hy * 2 - ZOOM);
                    set_color(COLOR_OPEN);
#endif
                    fill_rect(x - HEX_WIDTH / 2 + hx,
                              y - hy + 2,
                              (HEX_WIDTH / 2 - hx) * 2,
                              hy * 2 - ZOOM);
                }
                // **** draw hexagon end ****

                int td = map[i + MAP_TERRAIN_LAYER] * TERRAIN_DATA_SIZE;
                for (int a = 0;
                     a < terrainData[td + TERRAIN_DRAW_AMOUNT_OFFSET];
                     a++) {
                    int terrainColor =
                        terrainData[td + random_int(drawRnd, 2)]; //cheating
                    int xSpread
                        = terrainData[td + TERRAIN_DRAW_X_SPREAD_OFFSET];
                    int tx = x - xSpread / 2 + random_int(drawRnd, xSpread);
                    int ty = y - HEX_HEIGHT / 2 + random_int(drawRnd, HEX_HEIGHT);
                    int w = terrainData[td + TERRAIN_DRAW_WIDTH_OFFSET] * ZOOM;
                    int h = terrainData[td + TERRAIN_DRAW_HEIGHT_OFFSET] * ZOOM;
                    tx -= w / 2;
                    ty -= h / 2;
                    set_color(terrainColor);
                    fill_rect(tx, ty, w, h);
                }


                int unitImage = -1;
                int markImage = -1;
                int markColor = -1;
                int unitColor = -1;
                int borderColor = COLOR_FRIENDLY_BORDER;
                boolean mirror = false;

                int f = map[i + MAP_FRIENDLY_UNIT_LAYER];
                if (f > 0) {
                    unitImage = f;
                    unitColor = COLOR_FRIENDLY_BACKGROUND;
                    mirror = true;
                    if (map[i + MAP_FRIENDLY_MOVED_LAYER] > 0) {
                        borderColor = COLOR_MOVED_BORDER;
                        unitColor = COLOR_MOVED_BORDER;
                    }
                }

                if (map[i + MAP_FRIENDLY_FOV_LAYER] > 0) {
                    int e = map[i + MAP_ENEMY_UNIT_LAYER];
                    if (e > 0) {
                        unitImage = e;
                        unitColor = COLOR_ENEMY_BACKGROUND;
                        borderColor = COLOR_ENEMY_BORDER;
                        if (map[i + MAP_ATTACKED_LAYER] > 0) {
                            borderColor = COLOR_MOVED_BORDER;
                        }
                    }
                }

                markImage = map[i + MAP_MARK_LAYER];
                if (markImage != MARK_NONE) {
                    switch (markImage) {
                        case MARK_SELECTED:
                            markColor = COLOR_RED_2;
                            break;
                        case MARK_MOVE_TARGET:
                            markColor = COLOR_RED_1;
                            break;
                        case MARK_ATTACK_TARGET:
                            markColor = COLOR_RED_1;
                            break;
                    }
                }

                /*
                 * Set up pointers to image data to draw, and
                 * where to draw it, then loop and paint pixel by pixel.
                 * Saving some bytes not having to cache all images in
                 * Image objects, and even more bytes not having to
                 * fix transparent mark images.
                 * Hopefully fast enough on most machines.
                 */
                markImage *= BITMAP_DATA_SIZE;
                unitImage *= BITMAP_DATA_SIZE;

#ifndef PRINTABLE
                if (unitImage >= 0) {
                    set_color(borderColor);
                    fill_rect(x - BITMAP_WIDTH / 2 - UNIT_BORDER_WIDTH,
                              y - BITMAP_HEIGHT / 2 - UNIT_BORDER_WIDTH,
                              BITMAP_WIDTH + 2 * UNIT_BORDER_WIDTH,
                              BITMAP_HEIGHT + 2 * UNIT_BORDER_WIDTH);
                }

                /* idr = image data row, idc = image data column */
                for (int idr = 0; idr < BITMAP_DATA_HEIGHT; idr++) {
                    for (int idc = 0; idc < BITMAP_DATA_WIDTH; idc++) {
                        int color = -1;
                        if (unitImage >= 0) {
                            color = unitColor;
                            if (char_at(BITMAP_DATA, unitImage) == 'x') {
                                color = 0;
                            }
                        }
                        if (markImage >= 0
                            && char_at(BITMAP_DATA, markImage) == 'x') {
                            color = markColor;
                        }
                        if (color >= 0) {
                            int cx = idc;
                            if (mirror) {
                                cx = BITMAP_DATA_WIDTH - cx - 1;
                            }
                            set_color(color);
                            int x1 = x - BITMAP_WIDTH / 2
                                + cx * BITMAP_SCALE;
                            int y1 = y - BITMAP_HEIGHT / 2
                                + idr * BITMAP_SCALE;
                            fill_rect(x1, y1,
                                      BITMAP_SCALE, BITMAP_SCALE);
                        }
                        markImage++;
                        unitImage++;
                    }
                }

#endif

#ifdef DEBUG_ZOC
                if (map[i + MAP_ZOC_LAYER] > 0) {
                    set_color(RED);
                    fill_rect(x - BITMAP_WIDTH / 2 - 2,
                              y - BITMAP_WIDTH / 2 - 2,
                              4 * map[i + MAP_ZOC_LAYER], 4);
                }
#endif

#ifdef DEBUG_AI
    int[] colors = new int[] {0xffffff, 0x000000, 0x00ff00, 0x00ffff};
int debugY = y - BITMAP_HEIGHT / 2 + 1;
for (int layer = MAP_FRIENDLY_THREAT_LAYER;
     layer <= MAP_ENEMY_VALUE_LAYER;
     layer++) {
    set_color(colors[layer - MAP_FRIENDLY_THREAT_LAYER]);
    fill_rect(x - BITMAP_WIDTH / 2,
              debugY,
              map[i + layer] / 5, 2);
    debugY += 2;
}
#endif
                y += HEX_HEIGHT;
                i += MAP_DATA_SIZE;
            }
            x += MAP_COLUMN_DISTANCE;
        }

#ifdef PRINTABLE
        set_color(WHITE);
        fillAboveBelowColumns(g);
#else
    blit_buffer();
#endif
    }

#ifdef JAVA
    public boolean handleEvent(Event e) {
#ifdef DEBUG
    boolean instantWin = false;
#endif

        if (e.id != Event.MOUSE_DOWN) {
#ifdef DEBUG
        if (e.id == Event.KEY_PRESS) {
            switch (e.key) {
                case Event.ESCAPE:
                    Runtime.getRuntime().exit(0);
                    break;
                case Event.ENTER:
                    instantWin = true;
                    break;
                case 'm':
                    debugNextRandomMap();
                    state = NEW_LEVEL;
                    break;
                case 'M':
                    debugPrevRandomMap();
                    state = NEW_LEVEL;
                    break;
                case 'f':
                    debugNextRandomFriendlyUnits();
                    state = NEW_LEVEL;
                    break;
                case 'F':
                    debugPrevRandomFriendlyUnits();
                    state = NEW_LEVEL;
                    break;
                case 'e':
                    debugNextRandomEnemyUnits();
                    state = NEW_LEVEL;
                    break;
                case 't':
                    debugPlace = TANK;
                    System.out.println("debugPlace TANK");
                    break;
                case 'a':
                    debugPlace = ARTILLERY;
                    System.out.println("debugPlace ARTILLERY");
                    break;
                case 'n':
                    debugPlace = NO_UNIT;
                    System.out.println("debugPlace NO_UNIT");
                    break;
                case 'E':
                    debugPrevRandomEnemyUnits();
                    state = NEW_LEVEL;
                    break;
            }
        } else {
            return true;
        }
#else
            return true;
#endif
        }

#endif // JAVA
#ifdef C

    typedef struct EventStruct {
        int x;
        int y;
    } Event;

    bool handle_mouse_event(int mx, int my) {
        Event e;
        e.x = mx;
        e.y = my;

#endif
        // -------------- if we get here the event is a mouse click ----------

        if (e.y < SCREEN_BUTTON_HEIGHT
            && e.x > SCREEN_BUTTON_X) {
            // clicking the button
            switch (state) {
                case WON_LEVEL:
                    level++;
                case FAIL_LEVEL: //deliberate fall-through
                    state = NEW_LEVEL;
                    break;
                case WON_CAMPAIGN:
                    break;
                default:
                    turn++;
                    state = NEW_TURN;
                    if (turn > NR_TURNS) {
                        state = FAIL_LEVEL;
                    }
            }
        }

        if (state == NEW_LEVEL) {
            start();
            turn = 1;
            state = NEW_TURN;
        }

        int i = 0;
        /* Finding out what hex was clicked without using too many
         * bytes of code is done by looking for closest hex center.
         * The loop is here anyway for many other reasons.
         */
        int closestDistSquare = SCREEN_WIDTH * SCREEN_WIDTH
            + SCREEN_HEIGHT * SCREEN_HEIGHT; // ought to be big enough
        int x = MAP_FIRST_COLUMN_CENTER_X;
        int iClicked = 0;
        int iPrevSelected = -1;

        for (byte c = 0; c < MAP_COLUMNS; c++) {
            int y = ((c % 2 == 0) ? MAP_EVEN_ROW_LAYER : 0) + SCREEN_MAP_Y
                + HEX_HEIGHT / 2;
            for (byte r = 0; r < MAP_ROWS; r++) {
                int dx = x - e.x;
                int dy = y - e.y;
                int distSquare = dx * dx + dy * dy;
                if (distSquare < closestDistSquare
                   && e.y >= SCREEN_MAP_Y) {
                    iClicked = i;
                    closestDistSquare = distSquare;
                }
                if (map[i + MAP_MARK_LAYER] == MARK_SELECTED) {
                    iPrevSelected = i;
                }
                switch (state) {
                    case NEW_TURN:
                        map[i + MAP_FRIENDLY_FOV_LAYER] = 0;
                        if (map[i + MAP_FRIENDLY_UNIT_LAYER] > 0) {
                            map[i + MAP_FRIENDLY_FOV_LAYER] = FOV_RANGE;
                        }
                        map[i + MAP_MARK_LAYER] = MARK_NONE;
                        map[i + MAP_FRIENDLY_MOVED_LAYER] = 0;
                        map[i + MAP_ENEMY_MOVED_LAYER] = 0;
                        map[i + MAP_ATTACKED_LAYER] = 0;
                    case SELECT_UNIT_TO_MOVE: //deliberate fall-through
                        map[i + MAP_MARK_LAYER] = MARK_NONE;
                        map[i + MAP_ZOC_LAYER] = 0;
                        if (map[i + MAP_ENEMY_UNIT_LAYER] > 0) {
                            map[i + MAP_ZOC_LAYER] = 2;
                        }
                    case SHOW_TARGETS: //deliberate fall-through
                        map[i + MAP_MOVE_COST_LAYER] = 0;
                        map[i + MAP_RANGE_LAYER] = 0;
                        /*
                         * Save marks in TMP, since we want to
                         * clear the actual marks now.
                         */
                        map[i + MAP_TMP_LAYER] = map[i + MAP_MARK_LAYER];
                        map[i + MAP_MARK_LAYER] = MARK_NONE;
                        break;
                }
                i += MAP_DATA_SIZE;
                y += HEX_HEIGHT;
            }
            x += MAP_COLUMN_DISTANCE;
        }

#ifdef DEBUG
        System.out.print("clicked " + iClicked);
        for (int d = 0; d < MAP_DATA_SIZE; d++) {
            System.out.print(" " + map[iClicked + d]);
        }

        if (debugPlace != NO_UNIT) {
            System.out.print(" debugPlace");
            map[iClicked + MAP_FRIENDLY_UNIT_LAYER] = debugPlace;
        }

        System.out.println();
#endif

       /**
        * For knowing what map data to search.
        */
        int searchLayer = MAP_RANGE_LAYER;

        /**
         * What unit type we are searching for now, since that required
         * for figuring out movement and attack ranges etc.
         * This is an index into the unitData array. -1 means no unit at all
         * (but for searches that require a unit it will be a valid index
         * or things will go boom).
         * Also used for selected enemy unit during AI turn.
         */
        int searchUnitIndex = -1;

        /**
         * For searches related to a specific unit.
         */
        byte searchUnit = -1;


#ifdef DEBUG
        System.out.println(" state = "
                           + stateNames[state & NONE_SEARCH_STATE_MASK]
                           + " searchUnitIndex = " + searchUnitIndex);
#endif

       if ((state == SELECT_UNIT_TO_MOVE
            || state == SHOW_TARGETS)
           && map[iClicked + MAP_FRIENDLY_UNIT_LAYER] > 0
           && map[iClicked + MAP_FRIENDLY_MOVED_LAYER] == 0) {
           state = FIND_ENEMY_ZOC;
           searchUnit = map[iClicked + MAP_FRIENDLY_UNIT_LAYER];
           searchUnitIndex = (searchUnit - 1) * UNIT_SIZE;
       } else if (state == SHOW_TARGETS) {
           int terrain;
           int multiplier;
           int dr;
           // marks temporarily saved in TMP
           searchUnit = map[iPrevSelected + MAP_FRIENDLY_UNIT_LAYER];
           searchUnitIndex = (searchUnit - 1) * UNIT_SIZE;
           switch (map[iClicked + MAP_TMP_LAYER]) {
               case MARK_MOVE_TARGET:
                   map[iPrevSelected + MAP_FRIENDLY_UNIT_LAYER] = 0;
                   map[iClicked + MAP_FRIENDLY_UNIT_LAYER] = searchUnit;
                   map[iClicked + MAP_FRIENDLY_MOVED_LAYER] = 1;
                   map[iClicked + MAP_FRIENDLY_FOV_LAYER] = FOV_RANGE;
                   state = SELECT_UNIT_TO_MOVE;
                   break;
               case MARK_ATTACK_TARGET:
                   // FIXME move combat code to somewhere at end of method
                   // where it can be shared with AI attacks
                   terrain = map[iClicked + MAP_TERRAIN_LAYER];
                   multiplier = terrainData[terrain * TERRAIN_DATA_SIZE
                                                + TERRAIN_DEFENSE_OFFSET];
                   // if target has already been attacked this turn
                   if (map[iClicked + MAP_ATTACKED_LAYER] > 0
                       || (terrain == CITY && searchUnit == ENGINEER)) {
                       multiplier *= 2;
                   }

                   dr = random_int(rnd, 20); // roll a d20!
                   if (dr < multiplier) { // defender eliminated
                       map[iClicked + MAP_ENEMY_UNIT_LAYER] = 0;
                   }
#ifdef DEBUG
                   System.out.println("to hit: " + multiplier
                                      + " dr: " + dr);
#endif

                   // defender unit can fire back once per turn only
                   if (map[iClicked + MAP_ATTACKED_LAYER] == 0
                       && searchUnit != ARTILLERY) {
                       dr = random_int(rnd, 20); // roll d20 for defender firing
#ifdef DEBUG
                       System.out.println("enemy to hit: " + DEFENDER_FIRE_BACK
                                          + " dr: " + dr);
#endif
                       if (dr < DEFENDER_FIRE_BACK) {
                       // attacker eliminated
#ifdef DEBUG
                       System.out.println("attacker eliminated");
#endif
                       map[iPrevSelected + MAP_FRIENDLY_UNIT_LAYER] = 0;
                       }
                   }

                   // attacked unit marked as attacked... easier to kill off
                   map[iClicked + MAP_ATTACKED_LAYER] = 1;

                   map[iPrevSelected + MAP_FRIENDLY_MOVED_LAYER] = 1;
               default: //deliberate fall-through
                   state = SELECT_UNIT_TO_MOVE;
           }
       }

        while ((state & SEARCH_STATE_BIT) > 0) {

            int nrSearchIterations = 1;

            /**
             * For all values > 0 in the searchLayer data,
             * set corresponding value in this data (if >= 0).
             */
            int setFoundInLayer = -1;

            /**
             * What value to set in the setFoundInLayer data.
             */
            byte setFoundValue = 1;

            /**
             * Value to reset setFoundInLayer data to (if that is >= 0
             * and this one is >= -1)).
             * Why -1? Because MARK_NONE is -1, and that is the most likely
             * one to use here anyway.
             */
            byte resetFoundValue = -2;

            /**
             * If a value at this layer is 1, do not expand from that hex,
             * unless it is the start hex of the search (think ZOC).
             * If the value is >1, do not even expand into hex.
             * Implemented by setting value to 1 in that hex, since then it
             * can't expand further.
             */
            int blockLayer = -1;

            /**
             * Only hexes that have a > 0 value for this layer will
             * be considered for copying for setFoundInLayer.
             */
            int onlyKeepLayer = -1;

            /**
             * Hexes that have a > 0 value for this layer will
             * be set to 0 in the result (and that is done before
             * setFoundInLayer, if that is being done).
             */
            int notKeepLayer = -1;

            boolean waterBlocks = false;

            switch (state) {
                case SELECT_ENEMY_UNIT_TO_MOVE:
                    iPrevSelected = -1;
                    break;
                case FIND_ENEMY_ZOC:
                case FIND_FRIENDLY_ZOC: // same for both sides
                    searchLayer = MAP_ZOC_LAYER;
                    break;
                case FIND_FRIENDLY_THREAT:
                    //FIXME this is cheating, seeing all units on the map
                    searchLayer = MAP_FRIENDLY_THREAT_LAYER;
                    nrSearchIterations = THREAT_SEARCH_ITERATIONS;
                    waterBlocks = true;
                    break;
                case FIND_ENEMY_THREAT:
                    searchLayer = MAP_ENEMY_THREAT_LAYER;
                    nrSearchIterations = THREAT_SEARCH_ITERATIONS;
                    waterBlocks = true;
                    break;
                case FIND_ENEMY_VALUE:
                    searchLayer = MAP_ENEMY_VALUE_LAYER;
                    nrSearchIterations = VALUE_SEARCH_ITERATIONS;
                    waterBlocks = true;
                    break;
                case FIND_MOVE_TARGETS:
                    searchLayer = MAP_MOVE_COST_LAYER;
                    nrSearchIterations
                        = unitData[searchUnitIndex + UNIT_MOVE_OFFSET];
                    map[iClicked + MAP_MOVE_COST_LAYER]
                        = unitData[searchUnitIndex + UNIT_MOVE_OFFSET];
                    setFoundInLayer = MAP_MARK_LAYER;
                    setFoundValue = MARK_MOVE_TARGET;
                    resetFoundValue = MARK_NONE;
                    blockLayer = MAP_ZOC_LAYER;
                    notKeepLayer = MAP_FRIENDLY_UNIT_LAYER;
                    break;
                case FIND_ENEMY_MOVE_TARGETS:
                    searchLayer = MAP_MOVE_COST_LAYER;
                    nrSearchIterations
                        = unitData[searchUnitIndex + UNIT_MOVE_OFFSET];
                    map[iPrevSelected + MAP_MOVE_COST_LAYER]
                        = unitData[searchUnitIndex + UNIT_MOVE_OFFSET];
                    setFoundInLayer = MAP_MARK_LAYER;
                    setFoundValue = MARK_MOVE_TARGET;
                    resetFoundValue = MARK_NONE;
                    blockLayer = MAP_ZOC_LAYER;
                    notKeepLayer = MAP_ENEMY_UNIT_LAYER;
                    break;
                case FIND_ATTACK_TARGETS:
                    searchLayer = MAP_RANGE_LAYER;
                    byte range = (byte) (unitData[searchUnitIndex
                                                  + UNIT_RANGE_OFFSET]);
                    nrSearchIterations = range;
                    setFoundInLayer = MAP_MARK_LAYER;
                    map[iClicked + MAP_RANGE_LAYER] = range;
                    setFoundValue = MARK_ATTACK_TARGET;
                    resetFoundValue = -2;
                    blockLayer = -1;
                    onlyKeepLayer = MAP_ENEMY_UNIT_LAYER;
                    break;
                case FIND_ENEMY_ATTACK_TARGETS:
                    searchLayer = MAP_RANGE_LAYER;
                    range = (byte) (unitData[searchUnitIndex
                                             + UNIT_RANGE_OFFSET]);
                    nrSearchIterations = range;
                    setFoundInLayer = MAP_MARK_LAYER;
                    map[iPrevSelected + MAP_RANGE_LAYER] = range;
                    setFoundValue = MARK_ATTACK_TARGET;
                    resetFoundValue = -2;
                    blockLayer = -1;
                    onlyKeepLayer = MAP_FRIENDLY_UNIT_LAYER;
                    break;
                case NEW_TURN: // same as FIND_FRIENDLY_FOV
                case FIND_FRIENDLY_FOV:
                    searchLayer = MAP_FRIENDLY_FOV_LAYER;
                    nrSearchIterations = FOV_RANGE;
                    break;
                default:
                    setFoundInLayer = -1;
            }

#ifdef DEBUG
            System.out.println("  search state = "
                               + stateNames[state & NONE_SEARCH_STATE_MASK]
                               + " layer " + searchLayer);
#endif

            for (int searchIteration = 0; searchIteration < nrSearchIterations;
                 searchIteration++) {

                for (i = 0; i < MAP_DATA_TOTAL_SIZE; i += MAP_DATA_SIZE) {
                    if (state == FIND_FRIENDLY_ZOC) {
                        map[i + MAP_TMP_LAYER] = 0;
                        map[i + MAP_RANGE_LAYER] = 0;
                        map[i + MAP_MOVE_COST_LAYER] = 0;
                        map[i + MAP_FRIENDLY_THREAT_LAYER] = 0;
                        map[i + MAP_ENEMY_THREAT_LAYER] = 0;
                        map[i + MAP_ENEMY_VALUE_LAYER] = 0;
                        byte fu = map[i + MAP_FRIENDLY_UNIT_LAYER];
                        byte eu = map[i + MAP_ENEMY_UNIT_LAYER];
                        if (fu > 0) {
                            map[i + MAP_TMP_LAYER] = 2;
                            map[i + MAP_FRIENDLY_THREAT_LAYER]
                                = UNIT_THREAT;
                        } else if (eu > 0) {
                            map[i + MAP_ENEMY_THREAT_LAYER]
                                = UNIT_THREAT;
                            if (eu == ARTILLERY) {
                                map[i + MAP_ENEMY_VALUE_LAYER]
                                    += ARTILLERY_DEFEND_VALUE;
                            }
                        }
                        if (map[i + MAP_TERRAIN_LAYER] == CITY) {
                            map[i + MAP_ENEMY_VALUE_LAYER] += CITY_VALUE;
                        }
                    } else {
                        map[i + MAP_TMP_LAYER] = map[i + searchLayer];
                    }
                }
                i = 0;
                for (int c = 0; c < MAP_COLUMNS; c++) {
                    for (int r = 0; r < MAP_ROWS; r++) {
                        byte v = map[i + MAP_TMP_LAYER];
                        if (v > 1) {
                            // find all adjacent hexes
                            int_array(adj) = new_int_array {-1, -1, -1, -1, -1, -1};

                            /*
                             * I'm starting to think maybe I should have
                             * went with x,y coordinates rather than c,r...
                             */

                            // find adjacent up
                            if (r > 0) {
                                adj[0] = i - MAP_DATA_SIZE;
                            }
                            // find adjacent down
                            if (r < MAP_ROWS - 1) {
                                adj[3] = i + MAP_DATA_SIZE;
                            }
                            if (c % 2 == 0) { // EVEN COLUMN (shifted down)
                                if (c < MAP_COLUMNS - 1) {
                                    // find adjacent up-right from even
                                    adj[1] = i
                                        + MAP_ROWS * MAP_DATA_SIZE;
                                    // find adjacent down-right from even
                                    if (r < MAP_ROWS - 1) {
                                        adj[2] = i
                                            + (MAP_ROWS+1) * MAP_DATA_SIZE;
                                    }
                                }
                                if (c > 0) {
                                    // find adjacent down-left from even
                                    if (r < MAP_ROWS - 1) {
                                        adj[4] = i
                                            - (MAP_ROWS-1) * MAP_DATA_SIZE;
                                    }
                                    // find adjacent up-left from even
                                    adj[5] = i
                                        - MAP_ROWS * MAP_DATA_SIZE;
                                }
                            } else { // ODD COLUMN (shifted up)
                                if (c < MAP_COLUMNS - 1) {
                                    // find adjacent up-right from odd
                                    if (r > 0) {
                                        adj[1] = i
                                            + (MAP_ROWS-1) * MAP_DATA_SIZE;
                                    }
                                    // find adjacent down-right from odd
                                    adj[2] = i + MAP_ROWS * MAP_DATA_SIZE;
                                }
                                if (c > 0) {
                                    // find adjacent down-left from odd
                                    adj[4] = i - MAP_ROWS * MAP_DATA_SIZE;
                                    // find adjacent up-left from even
                                    if (r > 0) {
                                        adj[5] = i
                                            - (MAP_ROWS+1) * MAP_DATA_SIZE;
                                    }
                                }
                            }

                            // act on each found adjacent hex
                            for (int d = 0; d < 6; d++) {
                                if (adj[d] >= 0) {
                                    byte ev = (byte) (v - 1);
                                    byte bv = 0;

                                    /*
                                     * Hack to calculate movement costs.
                                     */
                                    if (searchLayer == MAP_MOVE_COST_LAYER) {
                                        int terrain
                                            = map[adj[d] + MAP_TERRAIN_LAYER];

                                        // engineer in water is a bridge hack
                                        if (terrain == WATER
                                            && map[adj[d]
                                                   + MAP_FRIENDLY_UNIT_LAYER]
                                            == ENGINEER) {
                                            // move cost is 1, so NOP here
                                        } else if (searchUnit == ENGINEER
                                                   && terrain == WATER
                                                   && v == 5) {
                                            ev = 1;
                                        } else {
                                            // normal terrain cost
                                            int terrainCost
                                                = terrainData[
                                                    terrain * TERRAIN_DATA_SIZE
                                                    + TERRAIN_MOVE_COST_OFFSET]
                                                ;
                                            ev = (byte)
                                                (v - terrainCost);
                                        }
                                    } else if (waterBlocks
                                              && map[adj[d]
                                                    + MAP_TERRAIN_LAYER]
                                              == WATER) {
                                        ev = 0;
                                    }

                                    byte ov = map[adj[d] + MAP_TMP_LAYER];
                                    if (blockLayer >= 0) {
                                        bv = map[adj[d] + blockLayer];
                                        if (bv > 0 && ev > 1) {
                                            ev = 1;
                                        }
                                    }

#ifdef EXTRA_DEBUG
                                    System.out.println("i = " + i
                                                       + " d = " + d
                                                       + " v = " + v
                                                       + " ov = " + ov
                                                       + " ev = " + ev
                                                       + " bv = " + bv);
#endif

                                    if (ev > ov && bv <= 1) {
                                        map[adj[d] + MAP_TMP_LAYER] = ev;
                                    }
                                }
                            }
                        }
                        i += MAP_DATA_SIZE;
                    }
                }
                for (i = 0; i < MAP_DATA_TOTAL_SIZE; i += MAP_DATA_SIZE) {
                    byte v = map[i + MAP_TMP_LAYER];
                    map[i + searchLayer] = v;
                }
            }

            for (i = 0; i < MAP_DATA_TOTAL_SIZE; i += MAP_DATA_SIZE) {
                if ((onlyKeepLayer >= 0
                     && map[i + onlyKeepLayer] == 0)
                    || (notKeepLayer >= 0
                        && map[i + notKeepLayer] > 0)) {
                    map[i + searchLayer] = 0;
                }
            }

            // for finding best enemy action in state FIND_ENEMY_ATTACK_TARGETS
            int bestValue = 0;
            int terrain;
            int multiplier;
            int dr;
            byte u;

            for (i = 0; i < MAP_DATA_TOTAL_SIZE; i += MAP_DATA_SIZE) {
                if (setFoundInLayer >= 0) {
                    if (resetFoundValue >= -1) {
                        map[i + setFoundInLayer] = resetFoundValue;
                    }
                    if (map[i + searchLayer] > 0) {
                        map[i + setFoundInLayer] = setFoundValue;
                    }
                }
                if (state == SELECT_ENEMY_UNIT_TO_MOVE
                    && map[i + MAP_ENEMY_UNIT_LAYER] > 0
                    && map[i + MAP_ENEMY_MOVED_LAYER] == 0) {
#ifdef DEBUG_AI
    System.out.println("selected enemy in " + i);
#endif
                    iPrevSelected = i;
                    searchUnitIndex
                        = (map[iPrevSelected + MAP_ENEMY_UNIT_LAYER]
                           - 1)
                        * UNIT_SIZE;
                } else if (state == FIND_ENEMY_ATTACK_TARGETS
                           && map[i + MAP_MARK_LAYER] != MARK_NONE) {
                    int value
                        = map[i + MAP_ENEMY_VALUE_LAYER]
                        + map[i + MAP_FRIENDLY_THREAT_LAYER];
                    if (value >= bestValue) {
                        bestValue = value;
                        iClicked = i;
                    }
                    map[i + MAP_TMP_LAYER] = map[i + MAP_MARK_LAYER];
                    map[i + MAP_MARK_LAYER] = MARK_NONE;
                }
            }

            switch (state) {
                case NEW_TURN:
                    state = SELECT_UNIT_TO_MOVE;
                    if (turn > 1) {
                        state = SELECT_ENEMY_UNIT_TO_MOVE;
                    }
                    break;
                case SELECT_ENEMY_UNIT_TO_MOVE:
                    state = FIND_FRIENDLY_ZOC;
                    if (iPrevSelected == -1) {// all enemy units have moved now
                        state = SELECT_UNIT_TO_MOVE;
                    }
                    break;
                case FIND_FRIENDLY_ZOC:
                    state = FIND_FRIENDLY_THREAT;
                    break;
                case FIND_FRIENDLY_THREAT:
                    state = FIND_ENEMY_THREAT;
                    break;
                case FIND_ENEMY_THREAT:
                    state = FIND_ENEMY_VALUE;
                    break;
                case FIND_ENEMY_VALUE:
                    state = FIND_ENEMY_MOVE_TARGETS;
                    break;
                case FIND_ENEMY_MOVE_TARGETS:
                    state = FIND_ENEMY_ATTACK_TARGETS;
                    break;
                case FIND_ENEMY_ATTACK_TARGETS:
                    // unit to move is still in iPrevSelected
                    // best action is in iClicked

#ifdef DEBUG_AI
    System.out.println(" enemy action from "
                      + iPrevSelected + " to " + iClicked
                      + " mark: " + map[iClicked + MAP_TMP_LAYER]);
#endif
                    u = map[iPrevSelected + MAP_ENEMY_UNIT_LAYER];

                    switch (map[iClicked + MAP_TMP_LAYER]) {
                        case MARK_MOVE_TARGET:
                            map[iPrevSelected + MAP_ENEMY_UNIT_LAYER] = 0;
                            map[iClicked + MAP_ENEMY_UNIT_LAYER] = u;
                            break;
                        case MARK_ATTACK_TARGET:
                            terrain = map[iClicked + MAP_TERRAIN_LAYER];
                            multiplier = terrainData[
                                terrain * TERRAIN_DATA_SIZE
                                + TERRAIN_DEFENSE_OFFSET];

                            // unit attacked multiple times is weaker
                            if (map[iClicked + MAP_ATTACKED_LAYER] > 0) {
                                multiplier *= 2;
                            }
                            dr = random_int(rnd, 20); // roll a d20!
                            if (dr < multiplier) { // defender eliminated
                                map[iClicked + MAP_FRIENDLY_UNIT_LAYER] = 0;
                            }
#ifdef DEBUG
                   System.out.println("enemy to hit: " + multiplier
                                      + " dr: " + dr);
#endif
    // roll d20 for defender firing back
                            // fires always at target in CLEAR terrain (0)
                            // but not at artillery
                            if (map[iClicked + MAP_ATTACKED_LAYER] > 0
                                && u != ARTILLERY) {
                                dr = random_int(rnd, 20);
#ifdef DEBUG
                                System.out.println("enemy to hit: "
                                                   + DEFENDER_FIRE_BACK
                                                   + " dr: " + dr);
#endif
                                 if (dr < DEFENDER_FIRE_BACK) {
                                     map[iPrevSelected
                                         + MAP_ENEMY_UNIT_LAYER] = 0;
                                 }
                             }
                            break;
                    }

                    // no matter what, clicked hex has moved now
                    // (either moved enemy unit, or attacked friendly unit)
                    map[iClicked + MAP_ENEMY_MOVED_LAYER] = 1;

                    // in case no move was made, original hex also is moved
                    map[iPrevSelected + MAP_ENEMY_MOVED_LAYER] = 1;

                    // then find next enemy unit to move (if any)
                    state = SELECT_ENEMY_UNIT_TO_MOVE;
                    break;
                case FIND_ENEMY_ZOC:
                    state = FIND_MOVE_TARGETS;
                    break;
                case FIND_MOVE_TARGETS:
                    state = FIND_ATTACK_TARGETS;
                    break;
                case FIND_ATTACK_TARGETS:
                    map[iClicked + MAP_MARK_LAYER] = MARK_SELECTED;
                    state = FIND_FRIENDLY_FOV;
                    break;
                case FIND_FRIENDLY_FOV:
                    state = SHOW_TARGETS;
                    break;
            }
        }

        // Checking for victory. Unfortunately there was no obvious
        // other loop to piggy-back this one to without running at
        // the start of the method, but that resulted in the bug
        // that you had to click somewhere to win the level after
        // moving into the last city, which was rather annoying.

        boolean victory = true;
        for (i = 0; i < MAP_DATA_TOTAL_SIZE; i += MAP_DATA_SIZE) {
            if (map[i + MAP_TERRAIN_LAYER] == CITY
                && map[i + MAP_FRIENDLY_UNIT_LAYER] == NO_UNIT) {
                victory = false;
            }
        }

        if (victory
#ifdef DEBUG
            || instantWin
#endif
) {
            state = WON_LEVEL;
            if (level == LAST_CAMPAIGN_SCENARIO) {
                state = WON_CAMPAIGN;
            }
        }

        repaint();
	return false;
    }

#if defined(JAVA) && defined(DEBUG)

private void debugNextRandomMap() {
    campaign[level * 3]++;
}

private void debugPrevRandomMap() {
    campaign[level * 3]--;
}

private void debugNextRandomFriendlyUnits() {
    campaign[level * 3 + 1]++;
}

private void debugPrevRandomFriendlyUnits() {
    campaign[level * 3 + 1]--;
}

private void debugNextRandomEnemyUnits() {
    campaign[level * 3 + 2]++;
}

private void debugPrevRandomEnemyUnits() {
    campaign[level * 3 + 2]--;
}

public static void main(String[] args) {
    Frame frame = new Frame();
    frame.setTitle("Wargame 4k (debug)");
    frame.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
    System.out.println(SCREEN_WIDTH + "x" + SCREEN_HEIGHT);
    frame.setLocation(1000, 100);
    frame.setResizable(false);
    G g = new G();
    frame.add(g);
    frame.show();
    g.start();
}
#endif

#if defined(C) && defined(SDL)
    int main(int argc, char *argv[]) {
        printf("General 4C\n");
        printf("%dx%d\n", SCREEN_WIDTH, SCREEN_HEIGHT);
        if (SDL_Init(SDL_INIT_VIDEO) < 0) {
            fprintf(stderr, "Failed to init SDL.");
            return 1;
        }
        window = SDL_CreateWindow("General 4C",
                                  SDL_WINDOWPOS_UNDEFINED,
                                  SDL_WINDOWPOS_UNDEFINED,
                                  SCREEN_WIDTH, SCREEN_HEIGHT,
                                  SDL_WINDOW_SHOWN );
        if(window == NULL) {
            fprintf(stderr, "Failed to create SDL window: %s\n",
                    SDL_GetError());
            return 1;
        }
        screen = SDL_GetWindowSurface(window);
        assert(screen != NULL);
        font = SDL_LoadBMP("font.bmp"); //FIXME search more locations
        if (font == NULL) {
            fprintf(stderr, "Failed to load 'font.bmp': %s\n",
                    SDL_GetError());
            return 1;
        }
        start();
        while (true) {
#ifdef SDL
            SDL_Event sdlevent;
            SDL_WaitEvent(&sdlevent);
            if (sdlevent.type == SDL_MOUSEBUTTONDOWN) {
                handle_mouse_event(sdlevent.button.x, sdlevent.button.y);
            } else if (sdlevent.type == SDL_QUIT) {
                break;
            }
#endif
        }

        SDL_DestroyWindow(window);

        return 0;
    }
#endif

#ifdef PRINTABLE
    public static void main(String[] args) throws Exception {
        G g = new G();
        for (int c = 0; c <= LAST_CAMPAIGN_SCENARIO; c++) {
            System.out.println("Rendering printable from scenario " + c + ".");
            g.level = c;
            g.start();
            BufferedImage image = new BufferedImage(SCREEN_WIDTH,
                                                    SCREEN_HEIGHT,
                                                    BufferedImage.TYPE_INT_RGB);
            g.paint(image.getGraphics());
            ImageIO.write(image, "PNG",
                          new File(String.format("G-map%d.png", c + 1)));
        }
    }
    private static void fillAboveBelowColumns(Graphics g) {
        int width = HEX_WIDTH / 2;
        for (int c = 0; c < MAP_COLUMNS; c++) {
            int x = MAP_FIRST_COLUMN_CENTER_X + MAP_COLUMN_DISTANCE * c;
            int yTop = ((c % 2 == 0) ? MAP_EVEN_ROW_LAYER : 0)
                + SCREEN_MAP_Y - ZOOM;
            int yBottom = SCREEN_HEIGHT
                - ((c % 2 == 0) ? 0 : MAP_EVEN_ROW_LAYER) - HEX_HEIGHT / 2
                + ZOOM - 2;
            fill_rect(x - width / 2,
                      0,
                      width,
                      yTop);
            fill_rect(x - width / 2,
                      yBottom,
                      width,
                      HEX_HEIGHT);
        }
    }

#endif

#ifdef JAVA
}
#endif
